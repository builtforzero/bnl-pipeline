{"version":3,"sources":["../node_modules/string-similarity/src/index.js","../node_modules/validatorjs/node_modules/date-fns/esm/toDate/index.js","../node_modules/validatorjs/node_modules/date-fns/esm/isValid/index.js","../node_modules/validatorjs/node_modules/date-fns/esm/_lib/toInteger/index.js","../node_modules/validatorjs/node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js","../node_modules/validatorjs/node_modules/date-fns/esm/parseISO/index.js","../node_modules/validatorjs/src/rules.js","../node_modules/validatorjs/src/attributes.js","../node_modules/validatorjs/src/messages.js","../node_modules/validatorjs/src/lang/en.js","../node_modules/validatorjs/src/lang.js","../node_modules/validatorjs/src/errors.js","../node_modules/validatorjs/src/async.js","../node_modules/validatorjs/src/validator.js","validator.js"],"names":["toDate","argument","arguments","length","TypeError","argStr","Object","prototype","toString","call","Date","getTime","console","warn","Error","stack","NaN","isValid","dirtyDate","date","isNaN","toInteger","dirtyNumber","number","Number","Math","ceil","floor","MILLISECONDS_IN_MINUTE","getTimezoneOffsetInMilliseconds","baseTimezoneOffset","getTimezoneOffset","setSeconds","millisecondsPartOfTimezoneOffset","MILLISECONDS_IN_HOUR","DEFAULT_ADDITIONAL_DIGITS","patterns","dateTimeDelimiter","timeZoneDelimiter","timezone","dateRegex","timeRegex","timezoneRegex","parseISO","dirtyOptions","options","additionalDigits","RangeError","dateStrings","splitDateString","parseYearResult","parseYear","parseDate","restDateString","year","timestamp","offset","time","parseTime","parseTimezone","fullTime","fullTimeDate","fullTimeDateNextDay","setDate","getDate","offsetDiff","dateString","timeString","array","split","test","substr","token","exec","replace","regex","RegExp","captures","match","parseInt","century","slice","isWeekDate","dayOfYear","parseDateUnit","month","day","week","dayOfWeek","validateWeekDate","dayOfISOWeekYear","validateDate","validateDayOfYearDate","setUTCFullYear","max","value","hours","parseTimeUnit","minutes","seconds","validateTime","parseFloat","timezoneString","sign","validateTimezone","isoWeekYear","fourthOfJanuaryDay","diff","getUTCDay","setUTCDate","getUTCDate","daysInMonths","isLeapYearIndex","_year","_hours","ValidatorEngine","state","dictionary","rules","input","metadata","customErrorMessages","searchTerm","stringSimilarity","a","require","findBestMatch","bestMatch","rating","target","rawArray","matchedArray","i","fuzzyMatchTerm","push","cleanArr","cleanItem","toLowerCase","data","Validator","log","validation","passes","values","errors","oldArr","newArr","matchedHeaders","fuzzyMatchArray","headers","originalHeaders","keys","raw","updateKeys","householdType","chronicArray","veteranArray","subpopArray"],"mappings":"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","file":"validator.87a664dc.js","sourceRoot":"..\\client","sourcesContent":["module.exports = {\n\tcompareTwoStrings,\n\tfindBestMatch\n};\n\nfunction compareTwoStrings(first, second) {\n\tfirst = first.replace(/\\s+/g, '')\n\tsecond = second.replace(/\\s+/g, '')\n\n\tif (!first.length && !second.length) return 1;                   // if both are empty strings\n\tif (!first.length || !second.length) return 0;                   // if only one is empty string\n\tif (first === second) return 1;       \t\t\t\t\t\t\t // identical\n\tif (first.length === 1 && second.length === 1) return 0;         // both are 1-letter strings\n\tif (first.length < 2 || second.length < 2) return 0;\t\t\t // if either is a 1-letter string\n\n\tlet firstBigrams = new Map();\n\tfor (let i = 0; i < first.length - 1; i++) {\n\t\tconst bigram = first.substring(i, i + 2);\n\t\tconst count = firstBigrams.has(bigram)\n\t\t\t? firstBigrams.get(bigram) + 1\n\t\t\t: 1;\n\n\t\tfirstBigrams.set(bigram, count);\n\t};\n\n\tlet intersectionSize = 0;\n\tfor (let i = 0; i < second.length - 1; i++) {\n\t\tconst bigram = second.substring(i, i + 2);\n\t\tconst count = firstBigrams.has(bigram)\n\t\t\t? firstBigrams.get(bigram)\n\t\t\t: 0;\n\n\t\tif (count > 0) {\n\t\t\tfirstBigrams.set(bigram, count - 1);\n\t\t\tintersectionSize++;\n\t\t}\n\t}\n\n\treturn (2.0 * intersectionSize) / (first.length + second.length - 2);\n}\n\nfunction findBestMatch(mainString, targetStrings) {\n\tif (!areArgsValid(mainString, targetStrings)) throw new Error('Bad arguments: First argument should be a string, second should be an array of strings');\n\t\n\tconst ratings = [];\n\tlet bestMatchIndex = 0;\n\n\tfor (let i = 0; i < targetStrings.length; i++) {\n\t\tconst currentTargetString = targetStrings[i];\n\t\tconst currentRating = compareTwoStrings(mainString, currentTargetString)\n\t\tratings.push({target: currentTargetString, rating: currentRating})\n\t\tif (currentRating > ratings[bestMatchIndex].rating) {\n\t\t\tbestMatchIndex = i\n\t\t}\n\t}\n\t\n\t\n\tconst bestMatch = ratings[bestMatchIndex]\n\t\n\treturn { ratings, bestMatch, bestMatchIndex };\n}\n\nfunction areArgsValid(mainString, targetStrings) {\n\tif (typeof mainString !== 'string') return false;\n\tif (!Array.isArray(targetStrings)) return false;\n\tif (!targetStrings.length) return false;\n\tif (targetStrings.find(s => typeof s !== 'string')) return false;\n\treturn true;\n}\n","/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @param {Date|Number} argument - the value to convert\n * @returns {Date} the parsed date in the local time zone\n * @throws {TypeError} 1 argument required\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\nexport default function toDate(argument) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present');\n  }\n\n  var argStr = Object.prototype.toString.call(argument); // Clone the date\n\n  if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime());\n  } else if (typeof argument === 'number' || argStr === '[object Number]') {\n    return new Date(argument);\n  } else {\n    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {\n      // eslint-disable-next-line no-console\n      console.warn(\"Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule\"); // eslint-disable-next-line no-console\n\n      console.warn(new Error().stack);\n    }\n\n    return new Date(NaN);\n  }\n}","import toDate from '../toDate/index.js';\n/**\n * @name isValid\n * @category Common Helpers\n * @summary Is the given date valid?\n *\n * @description\n * Returns false if argument is Invalid Date and true otherwise.\n * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}\n * Invalid Date is a Date, whose time value is NaN.\n *\n * Time value of Date: http://es5.github.io/#x15.9.1.1\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * - Now `isValid` doesn't throw an exception\n *   if the first argument is not an instance of Date.\n *   Instead, argument is converted beforehand using `toDate`.\n *\n *   Examples:\n *\n *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |\n *   |---------------------------|---------------|---------------|\n *   | `new Date()`              | `true`        | `true`        |\n *   | `new Date('2016-01-01')`  | `true`        | `true`        |\n *   | `new Date('')`            | `false`       | `false`       |\n *   | `new Date(1488370835081)` | `true`        | `true`        |\n *   | `new Date(NaN)`           | `false`       | `false`       |\n *   | `'2016-01-01'`            | `TypeError`   | `true`        |\n *   | `''`                      | `TypeError`   | `false`       |\n *   | `1488370835081`           | `TypeError`   | `true`        |\n *   | `NaN`                     | `TypeError`   | `false`       |\n *\n *   We introduce this change to make *date-fns* consistent with ECMAScript behavior\n *   that try to coerce arguments to the expected type\n *   (which is also the case with other *date-fns* functions).\n *\n * @param {*} date - the date to check\n * @returns {Boolean} the date is valid\n * @throws {TypeError} 1 argument required\n *\n * @example\n * // For the valid date:\n * var result = isValid(new Date(2014, 1, 31))\n * //=> true\n *\n * @example\n * // For the value, convertable into a date:\n * var result = isValid(1393804800000)\n * //=> true\n *\n * @example\n * // For the invalid date:\n * var result = isValid(new Date(''))\n * //=> false\n */\n\nexport default function isValid(dirtyDate) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present');\n  }\n\n  var date = toDate(dirtyDate);\n  return !isNaN(date);\n}","export default function toInteger(dirtyNumber) {\n  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {\n    return NaN;\n  }\n\n  var number = Number(dirtyNumber);\n\n  if (isNaN(number)) {\n    return number;\n  }\n\n  return number < 0 ? Math.ceil(number) : Math.floor(number);\n}","var MILLISECONDS_IN_MINUTE = 60000;\n/**\n * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.\n * They usually appear for dates that denote time before the timezones were introduced\n * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891\n * and GMT+01:00:00 after that date)\n *\n * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,\n * which would lead to incorrect calculations.\n *\n * This function returns the timezone offset in milliseconds that takes seconds in account.\n */\n\nexport default function getTimezoneOffsetInMilliseconds(dirtyDate) {\n  var date = new Date(dirtyDate.getTime());\n  var baseTimezoneOffset = date.getTimezoneOffset();\n  date.setSeconds(0, 0);\n  var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;\n  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;\n}","import toInteger from '../_lib/toInteger/index.js';\nimport getTimezoneOffsetInMilliseconds from '../_lib/getTimezoneOffsetInMilliseconds/index.js';\nvar MILLISECONDS_IN_HOUR = 3600000;\nvar MILLISECONDS_IN_MINUTE = 60000;\nvar DEFAULT_ADDITIONAL_DIGITS = 2;\nvar patterns = {\n  dateTimeDelimiter: /[T ]/,\n  timeZoneDelimiter: /[Z ]/i,\n  timezone: /([Z+-].*)$/\n};\nvar dateRegex = /^-?(?:(\\d{3})|(\\d{2})(?:-?(\\d{2}))?|W(\\d{2})(?:-?(\\d{1}))?|)$/;\nvar timeRegex = /^(\\d{2}(?:[.,]\\d*)?)(?::?(\\d{2}(?:[.,]\\d*)?))?(?::?(\\d{2}(?:[.,]\\d*)?))?$/;\nvar timezoneRegex = /^([+-])(\\d{2})(?::?(\\d{2}))?$/;\n/**\n * @name parseISO\n * @category Common Helpers\n * @summary Parse ISO string\n *\n * @description\n * Parse the given string in ISO 8601 format and return an instance of Date.\n *\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n *\n * If the argument isn't a string, the function cannot parse the string or\n * the values are invalid, it returns Invalid Date.\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * - The previous `parse` implementation was renamed to `parseISO`.\n *\n *   ```javascript\n *   // Before v2.0.0\n *   parse('2016-01-01')\n *\n *   // v2.0.0 onward\n *   parseISO('2016-01-01')\n *   ```\n *\n * - `parseISO` now validates separate date and time values in ISO-8601 strings\n *   and returns `Invalid Date` if the date is invalid.\n *\n *   ```javascript\n *   parseISO('2018-13-32')\n *   //=> Invalid Date\n *   ```\n *\n * - `parseISO` now doesn't fall back to `new Date` constructor\n *   if it fails to parse a string argument. Instead, it returns `Invalid Date`.\n *\n * @param {String} argument - the value to convert\n * @param {Object} [options] - an object with options.\n * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format\n * @returns {Date} the parsed date in the local time zone\n * @throws {TypeError} 1 argument required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * var result = parseISO('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert string '+02014101' to date,\n * // if the additional number of digits in the extended year format is 1:\n * var result = parseISO('+02014101', { additionalDigits: 1 })\n * //=> Fri Apr 11 2014 00:00:00\n */\n\nexport default function parseISO(argument, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present');\n  }\n\n  var options = dirtyOptions || {};\n  var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger(options.additionalDigits);\n\n  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {\n    throw new RangeError('additionalDigits must be 0, 1 or 2');\n  }\n\n  if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {\n    return new Date(NaN);\n  }\n\n  var dateStrings = splitDateString(argument);\n  var date;\n\n  if (dateStrings.date) {\n    var parseYearResult = parseYear(dateStrings.date, additionalDigits);\n    date = parseDate(parseYearResult.restDateString, parseYearResult.year);\n  }\n\n  if (isNaN(date) || !date) {\n    return new Date(NaN);\n  }\n\n  var timestamp = date.getTime();\n  var time = 0;\n  var offset;\n\n  if (dateStrings.time) {\n    time = parseTime(dateStrings.time);\n\n    if (isNaN(time) || time === null) {\n      return new Date(NaN);\n    }\n  }\n\n  if (dateStrings.timezone) {\n    offset = parseTimezone(dateStrings.timezone);\n\n    if (isNaN(offset)) {\n      return new Date(NaN);\n    }\n  } else {\n    var fullTime = timestamp + time;\n    var fullTimeDate = new Date(fullTime);\n    offset = getTimezoneOffsetInMilliseconds(fullTimeDate); // Adjust time when it's coming from DST\n\n    var fullTimeDateNextDay = new Date(fullTime);\n    fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1);\n    var offsetDiff = getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) - offset;\n\n    if (offsetDiff > 0) {\n      offset += offsetDiff;\n    }\n  }\n\n  return new Date(timestamp + time + offset);\n}\n\nfunction splitDateString(dateString) {\n  var dateStrings = {};\n  var array = dateString.split(patterns.dateTimeDelimiter);\n  var timeString;\n\n  if (/:/.test(array[0])) {\n    dateStrings.date = null;\n    timeString = array[0];\n  } else {\n    dateStrings.date = array[0];\n    timeString = array[1];\n\n    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {\n      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];\n      timeString = dateString.substr(dateStrings.date.length, dateString.length);\n    }\n  }\n\n  if (timeString) {\n    var token = patterns.timezone.exec(timeString);\n\n    if (token) {\n      dateStrings.time = timeString.replace(token[1], '');\n      dateStrings.timezone = token[1];\n    } else {\n      dateStrings.time = timeString;\n    }\n  }\n\n  return dateStrings;\n}\n\nfunction parseYear(dateString, additionalDigits) {\n  var regex = new RegExp('^(?:(\\\\d{4}|[+-]\\\\d{' + (4 + additionalDigits) + '})|(\\\\d{2}|[+-]\\\\d{' + (2 + additionalDigits) + '})$)');\n  var captures = dateString.match(regex); // Invalid ISO-formatted year\n\n  if (!captures) return {\n    year: null\n  };\n  var year = captures[1] && parseInt(captures[1]);\n  var century = captures[2] && parseInt(captures[2]);\n  return {\n    year: century == null ? year : century * 100,\n    restDateString: dateString.slice((captures[1] || captures[2]).length)\n  };\n}\n\nfunction parseDate(dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) return null;\n  var captures = dateString.match(dateRegex); // Invalid ISO-formatted string\n\n  if (!captures) return null;\n  var isWeekDate = !!captures[4];\n  var dayOfYear = parseDateUnit(captures[1]);\n  var month = parseDateUnit(captures[2]) - 1;\n  var day = parseDateUnit(captures[3]);\n  var week = parseDateUnit(captures[4]);\n  var dayOfWeek = parseDateUnit(captures[5]) - 1;\n\n  if (isWeekDate) {\n    if (!validateWeekDate(year, week, dayOfWeek)) {\n      return new Date(NaN);\n    }\n\n    return dayOfISOWeekYear(year, week, dayOfWeek);\n  } else {\n    var date = new Date(0);\n\n    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {\n      return new Date(NaN);\n    }\n\n    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));\n    return date;\n  }\n}\n\nfunction parseDateUnit(value) {\n  return value ? parseInt(value) : 1;\n}\n\nfunction parseTime(timeString) {\n  var captures = timeString.match(timeRegex);\n  if (!captures) return null; // Invalid ISO-formatted time\n\n  var hours = parseTimeUnit(captures[1]);\n  var minutes = parseTimeUnit(captures[2]);\n  var seconds = parseTimeUnit(captures[3]);\n\n  if (!validateTime(hours, minutes, seconds)) {\n    return NaN;\n  }\n\n  return hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;\n}\n\nfunction parseTimeUnit(value) {\n  return value && parseFloat(value.replace(',', '.')) || 0;\n}\n\nfunction parseTimezone(timezoneString) {\n  if (timezoneString === 'Z') return 0;\n  var captures = timezoneString.match(timezoneRegex);\n  if (!captures) return 0;\n  var sign = captures[1] === '+' ? -1 : 1;\n  var hours = parseInt(captures[2]);\n  var minutes = captures[3] && parseInt(captures[3]) || 0;\n\n  if (!validateTimezone(hours, minutes)) {\n    return NaN;\n  }\n\n  return sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE);\n}\n\nfunction dayOfISOWeekYear(isoWeekYear, week, day) {\n  var date = new Date(0);\n  date.setUTCFullYear(isoWeekYear, 0, 4);\n  var fourthOfJanuaryDay = date.getUTCDay() || 7;\n  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;\n  date.setUTCDate(date.getUTCDate() + diff);\n  return date;\n} // Validation functions\n// February is null to handle the leap year (using ||)\n\n\nvar daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\nfunction isLeapYearIndex(year) {\n  return year % 400 === 0 || year % 4 === 0 && year % 100;\n}\n\nfunction validateDate(year, month, date) {\n  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));\n}\n\nfunction validateDayOfYearDate(year, dayOfYear) {\n  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);\n}\n\nfunction validateWeekDate(_year, week, day) {\n  return week >= 1 && week <= 53 && day >= 0 && day <= 6;\n}\n\nfunction validateTime(hours, minutes, seconds) {\n  if (hours === 24) {\n    return minutes === 0 && seconds === 0;\n  }\n\n  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;\n}\n\nfunction validateTimezone(_hours, minutes) {\n  return minutes >= 0 && minutes <= 59;\n}","var isValid = require(\"date-fns/isValid\");\nvar parseISO = require(\"date-fns/parseISO\");\n\n\nfunction leapYear(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n}\n\nfunction isValidDate(inDate) {\n  if (inDate instanceof Date) {\n    return !isNaN(inDate);\n  }\n\n  // reformat if supplied as mm.dd.yyyy (period delimiter)\n  if (typeof inDate === \"string\") {\n    var pos = inDate.indexOf(\".\");\n    if (pos > 0 && pos <= 6) {\n      inDate = inDate.replace(/\\./g, \"-\");\n    }\n\n    // if date is mm-dd-yyyy or yyyy-mm-dd\n    if (inDate.length === 10) {\n      return isValid(parseISO(inDate));\n    }\n  }\n\n  var testDate = new Date(inDate);\n  var yr = testDate.getFullYear();\n  var mo = testDate.getMonth();\n  var day = testDate.getDate();\n\n  var daysInMonth = [31, leapYear(yr) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  if (yr < 1000) {\n    return false;\n  }\n  if (isNaN(mo)) {\n    return false;\n  }\n  if (mo + 1 > 12) {\n    return false;\n  }\n  if (isNaN(day)) {\n    return false;\n  }\n  if (day > daysInMonth[mo]) {\n    return false;\n  }\n\n  return true;\n}\n\nvar rules = {\n  required: function(val) {\n    var str;\n\n    if (val === undefined || val === null) {\n      return false;\n    }\n\n    str = String(val).replace(/\\s/g, \"\");\n    return str.length > 0 ? true : false;\n  },\n\n  required_if: function(val, req, attribute) {\n    req = this.getParameters();\n    if (this.validator._objectPath(this.validator.input, req[0]) === req[1]) {\n      return this.validator.getRule(\"required\").validate(val);\n    }\n\n    return true;\n  },\n\n  required_unless: function(val, req, attribute) {\n    req = this.getParameters();\n    if (this.validator._objectPath(this.validator.input, req[0]) !== req[1]) {\n      return this.validator.getRule(\"required\").validate(val);\n    }\n\n    return true;\n  },\n\n  required_with: function(val, req, attribute) {\n    if (this.validator._objectPath(this.validator.input, req)) {\n      return this.validator.getRule(\"required\").validate(val);\n    }\n\n    return true;\n  },\n\n  required_with_all: function(val, req, attribute) {\n    req = this.getParameters();\n\n    for (var i = 0; i < req.length; i++) {\n      if (!this.validator._objectPath(this.validator.input, req[i])) {\n        return true;\n      }\n    }\n\n    return this.validator.getRule(\"required\").validate(val);\n  },\n\n  required_without: function(val, req, attribute) {\n    if (this.validator._objectPath(this.validator.input, req)) {\n      return true;\n    }\n\n    return this.validator.getRule(\"required\").validate(val);\n  },\n\n  required_without_all: function(val, req, attribute) {\n    req = this.getParameters();\n\n    for (var i = 0; i < req.length; i++) {\n      if (this.validator._objectPath(this.validator.input, req[i])) {\n        return true;\n      }\n    }\n\n    return this.validator.getRule(\"required\").validate(val);\n  },\n\n  boolean: function(val) {\n    return (\n      val === true ||\n      val === false ||\n      val === 0 ||\n      val === 1 ||\n      val === \"0\" ||\n      val === \"1\" ||\n      val === \"true\" ||\n      val === \"false\"\n    );\n  },\n\n  // compares the size of strings\n  // with numbers, compares the value\n  size: function(val, req, attribute) {\n    if (val) {\n      req = parseFloat(req);\n\n      var size = this.getSize();\n\n      return size === req;\n    }\n\n    return true;\n  },\n\n  string: function(val, req, attribute) {\n    return typeof val === \"string\";\n  },\n\n  sometimes: function(val) {\n    return true;\n  },\n\n  /**\n   * Compares the size of strings or the value of numbers if there is a truthy value\n   */\n  min: function (val, req, attribute) {\n    var size = this.getSize();\n    return size >= req;\n  },\n\n  /**\n   * Compares the size of strings or the value of numbers if there is a truthy value\n   */\n  max: function(val, req, attribute) {\n    var size = this.getSize();\n    return size <= req;\n  },\n\n  between: function(val, req, attribute) {\n    req = this.getParameters();\n    var size = this.getSize();\n    var min = parseFloat(req[0], 10);\n    var max = parseFloat(req[1], 10);\n    return size >= min && size <= max;\n  },\n\n  email: function(val) {\n    // Added umlaut support https://github.com/skaterdav85/validatorjs/issues/308\n    var re = /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n    if (!re.test(val)) {\n      re = /^((?:[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]|[^\\u0000-\\u007F])+@(?:[a-zA-Z0-9]|[^\\u0000-\\u007F])(?:(?:[a-zA-Z0-9-]|[^\\u0000-\\u007F]){0,61}(?:[a-zA-Z0-9]|[^\\u0000-\\u007F]))?(?:\\.(?:[a-zA-Z0-9]|[^\\u0000-\\u007F])(?:(?:[a-zA-Z0-9-]|[^\\u0000-\\u007F]){0,61}(?:[a-zA-Z0-9]|[^\\u0000-\\u007F]))?))*$/;\n    }\n    return re.test(val);\n  },\n\n  numeric: function(val) {\n    var num;\n\n    num = Number(val); // tries to convert value to a number. useful if value is coming from form element\n\n    if (typeof num === \"number\" && !isNaN(num) && typeof val !== \"boolean\") {\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  array: function (val) {\n    return val instanceof Array;\n  },\n\n  url: function(url) {\n    return /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-z]{2,63}\\b([-a-zA-Z0-9@:%_\\+.~#?&/=]*)/i.test(url);\n  },\n\n  alpha: function(val) {\n    return /^[a-zA-Z]+$/.test(val);\n  },\n\n  alpha_dash: function(val) {\n    return /^[a-zA-Z0-9_\\-]+$/.test(val);\n  },\n\n  alpha_num: function(val) {\n    return /^[a-zA-Z0-9]+$/.test(val);\n  },\n\n  same: function(val, req) {\n    var val1 = this.validator._flattenObject(this.validator.input)[req];\n    var val2 = val;\n\n    if (val1 === val2) {\n      return true;\n    }\n\n    return false;\n  },\n\n  different: function(val, req) {\n    var val1 = this.validator._flattenObject(this.validator.input)[req];\n    var val2 = val;\n\n    if (val1 !== val2) {\n      return true;\n    }\n\n    return false;\n  },\n\n  in: function(val, req) {\n    var list, i;\n\n    if (val) {\n      list = this.getParameters();\n    }\n\n    if (val && !(val instanceof Array)) {\n      var localValue = val;\n\n      for (i = 0; i < list.length; i++) {\n        if (typeof list[i] === \"string\") {\n          localValue = String(val);\n        }\n\n        if (localValue === list[i]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    if (val && val instanceof Array) {\n      for (i = 0; i < val.length; i++) {\n        if (list.indexOf(val[i]) < 0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  },\n\n  not_in: function(val, req) {\n    var list = this.getParameters();\n    var len = list.length;\n    var returnVal = true;\n\n    for (var i = 0; i < len; i++) {\n      var localValue = val;\n\n      if (typeof list[i] === \"string\") {\n        localValue = String(val);\n      }\n\n      if (localValue === list[i]) {\n        returnVal = false;\n        break;\n      }\n    }\n\n    return returnVal;\n  },\n\n  accepted: function(val) {\n    if (val === \"on\" || val === \"yes\" || val === 1 || val === \"1\" || val === true) {\n      return true;\n    }\n\n    return false;\n  },\n\n  confirmed: function(val, req, key) {\n    var confirmedKey = key + \"_confirmation\";\n\n    if (this.validator.input[confirmedKey] === val) {\n      return true;\n    }\n\n    return false;\n  },\n\n  integer: function(val) {\n    return String(parseInt(val, 10)) === String(val);\n  },\n\n  digits: function(val, req) {\n    var numericRule = this.validator.getRule('numeric');\n    if (numericRule.validate(val) && String(val.trim()).length === parseInt(req)) {\n      return true;\n    }\n\n    return false;\n  },\n\n  digits_between: function(val) {\n    var numericRule = this.validator.getRule(\"numeric\");\n    var req = this.getParameters();\n    var valueDigitsCount = String(val).length;\n    var min = parseFloat(req[0], 10);\n    var max = parseFloat(req[1], 10);\n\n    if (numericRule.validate(val) && valueDigitsCount >= min && valueDigitsCount <= max) {\n      return true;\n    }\n\n    return false;\n  },\n\n  regex: function(val, req) {\n    var mod = /[g|i|m]{1,3}$/;\n    var flag = req.match(mod);\n    flag = flag ? flag[0] : \"\";\n    req = req.replace(mod, \"\").slice(1, -1);\n    req = new RegExp(req, flag);\n    return !!req.test(val);\n  },\n\n  date: function(val, format) {\n    return isValidDate(val);\n  },\n\n  present: function(val) {\n    return typeof val !== \"undefined\";\n  },\n\n  after: function(val, req) {\n    var val1 = this.validator.input[req];\n    var val2 = val;\n\n    if (!isValidDate(val1)) {\n      return false;\n    }\n    if (!isValidDate(val2)) {\n      return false;\n    }\n\n    if (new Date(val1).getTime() < new Date(val2).getTime()) {\n      return true;\n    }\n\n    return false;\n  },\n\n  after_or_equal: function(val, req) {\n    var val1 = this.validator.input[req];\n    var val2 = val;\n\n    if (!isValidDate(val1)) {\n      return false;\n    }\n    if (!isValidDate(val2)) {\n      return false;\n    }\n\n    if (new Date(val1).getTime() <= new Date(val2).getTime()) {\n      return true;\n    }\n\n    return false;\n  },\n\n  before: function(val, req) {\n    var val1 = this.validator.input[req];\n    var val2 = val;\n\n    if (!isValidDate(val1)) {\n      return false;\n    }\n    if (!isValidDate(val2)) {\n      return false;\n    }\n\n    if (new Date(val1).getTime() > new Date(val2).getTime()) {\n      return true;\n    }\n\n    return false;\n  },\n\n  before_or_equal: function(val, req) {\n    var val1 = this.validator.input[req];\n    var val2 = val;\n\n    if (!isValidDate(val1)) {\n      return false;\n    }\n    if (!isValidDate(val2)) {\n      return false;\n    }\n\n    if (new Date(val1).getTime() >= new Date(val2).getTime()) {\n      return true;\n    }\n\n    return false;\n  },\n\n  hex: function(val) {\n    return /^[0-9a-f]+$/i.test(val);\n  },\n\n  ipv4: function (val, req, attribute) {\n    if (typeof val != 'string')\n      return false;\n\n    // regex to check that each octet is valid\n    var er = /^[0-9]+$/;\n    // ipv4 octets are delimited by dot\n    octets = val.split('.');\n    // check 1: ipv4 address should contains 4 octets\n    if (octets.length != 4)\n      return false;\n\n    for (let i = 0; i < octets.length; i++) {\n      const element = octets[i];\n      // check 2: each octet should be integer bigger than 0\n      if (!er.test(element))\n        return false;\n\n      // check 3: each octet value should be less than 256\n      var octetValue = parseInt(element);\n      if (octetValue >= 256)\n        return false;\n    }\n\n    // if all checks passed, we know it's valid IPv4 address!\n    return true;\n  },\n\n  ipv6: function (val, req, attribute) {\n    if (typeof val != 'string')\n      return false;\n\n    // regex to check that each hextet is valid\n    var er = /^[0-9a-f]+$/;\n    // ipv6 hextets are delimited by colon\n    hextets = val.split(':');\n\n    // check 1: ipv6 should contain only one consecutive colons\n    colons = val.match(/::/);\n    if (colons != null && val.match(/::/g).length > 1)\n      return false;\n\n    // check 2: ipv6 should not be ending or starting with colon\n    //          edge case: not with consecutive colons\n    if (val[0] == ':' && (colons == null || (colons != null && colons.index != 0)))\n      return false;\n    if (val[val.length - 1] == ':' && (colons == null || (colons != null && colons.index != val.length - 2)))\n      return false;\n\n    // check 3: ipv6 should contain no less than 3 sector\n    //         minimum ipv6 addres - ::1\n    if (3 > hextets.length)\n      return false;\n\n    // check 4: ipv6 should contain no more than 8 sectors\n    //         only 1 edge case: when first or last sector is ommited\n    var isEdgeCase = (hextets.length == 9 && colons != null && (colons.index == 0 || colons.index == val.length - 2));\n    if (hextets.length > 8 && !isEdgeCase)\n      return false;\n\n    // check 5: ipv6 should contain exactly one consecutive colons if it has less than 8 sectors\n    if (hextets.length != 8 && colons == null)\n      return false;\n\n    for (let i = 0; i < hextets.length; i++) {\n      const element = hextets[i];\n\n      if (element.length == 0)\n        continue;\n\n      // check 6: all of hextets should contain numbers from 0 to f (in hexadecimal)\n      if (!er.test(element))\n        return false;\n\n      // check 7: all of hextet values should be less then ffff (in hexadeimal)\n      //          checking using length of hextet. lowest invalid value's length is 5.\n      //          so all valid hextets are length of 4 or less\n      if (element.length > 4)\n        return false;\n    }\n    return true;\n  },\n\n  ip: function (val, req, attribute) {\n    return rules['ipv4'](val, req, attribute) || rules['ipv6'](val, req, attribute);\n  }\n\n};\n\nvar missedRuleValidator = function() {\n  throw new Error(\"Validator `\" + this.name + \"` is not defined!\");\n};\nvar missedRuleMessage;\n\nfunction Rule(name, fn, async) {\n  this.name = name;\n  this.fn = fn;\n  this.passes = null;\n  this._customMessage = undefined;\n  this.async = async;\n}\n\nRule.prototype = {\n  /**\n   * Validate rule\n   *\n   * @param  {mixed} inputValue\n   * @param  {mixed} ruleValue\n   * @param  {string} attribute\n   * @param  {function} callback\n   * @return {boolean|undefined}\n   */\n  validate: function(inputValue, ruleValue, attribute, callback) {\n    var _this = this;\n    this._setValidatingData(attribute, inputValue, ruleValue);\n    if (typeof callback === \"function\") {\n      this.callback = callback;\n      var handleResponse = function(passes, message) {\n        _this.response(passes, message);\n      };\n\n      if (this.async) {\n        return this._apply(inputValue, ruleValue, attribute, handleResponse);\n      } else {\n        return handleResponse(this._apply(inputValue, ruleValue, attribute));\n      }\n    }\n    return this._apply(inputValue, ruleValue, attribute);\n  },\n\n  /**\n   * Apply validation function\n   *\n   * @param  {mixed} inputValue\n   * @param  {mixed} ruleValue\n   * @param  {string} attribute\n   * @param  {function} callback\n   * @return {boolean|undefined}\n   */\n  _apply: function(inputValue, ruleValue, attribute, callback) {\n    var fn = this.isMissed() ? missedRuleValidator : this.fn;\n\n    return fn.apply(this, [inputValue, ruleValue, attribute, callback]);\n  },\n\n  /**\n   * Set validating data\n   *\n   * @param {string} attribute\n   * @param {mixed} inputValue\n   * @param {mixed} ruleValue\n   * @return {void}\n   */\n  _setValidatingData: function(attribute, inputValue, ruleValue) {\n    this.attribute = attribute;\n    this.inputValue = inputValue;\n    this.ruleValue = ruleValue;\n  },\n\n  /**\n   * Get parameters\n   *\n   * @return {array}\n   */\n  getParameters: function() {\n    var value = [];\n\n    if (typeof this.ruleValue === \"string\") {\n      value = this.ruleValue.split(\",\");\n    }\n\n    if (typeof this.ruleValue === \"number\") {\n      value.push(this.ruleValue);\n    }\n\n    if (this.ruleValue instanceof Array) {\n      value = this.ruleValue;\n    }\n\n    return value;\n  },\n\n  /**\n   * Get true size of value\n   *\n   * @return {integer|float}\n   */\n  getSize: function() {\n    var value = this.inputValue;\n\n    if (value instanceof Array) {\n      return value.length;\n    }\n\n    if (typeof value === \"number\") {\n      return value;\n    }\n\n    if (this.validator._hasNumericRule(this.attribute)) {\n      return parseFloat(value, 10);\n    }\n\n    return value.length;\n  },\n\n  /**\n   * Get the type of value being checked; numeric or string.\n   *\n   * @return {string}\n   */\n  _getValueType: function() {\n    if (typeof this.inputValue === \"number\" || this.validator._hasNumericRule(this.attribute)) {\n      return \"numeric\";\n    }\n\n    return \"string\";\n  },\n\n  /**\n   * Set the async callback response\n   *\n   * @param  {boolean|undefined} passes  Whether validation passed\n   * @param  {string|undefined} message Custom error message\n   * @return {void}\n   */\n  response: function(passes, message) {\n    this.passes = passes === undefined || passes === true;\n    this._customMessage = message;\n    this.callback(this.passes, message);\n  },\n\n  /**\n   * Set validator instance\n   *\n   * @param {Validator} validator\n   * @return {void}\n   */\n  setValidator: function(validator) {\n    this.validator = validator;\n  },\n\n  /**\n   * Check if rule is missed\n   *\n   * @return {boolean}\n   */\n  isMissed: function() {\n    return typeof this.fn !== \"function\";\n  },\n\n  get customMessage() {\n    return this.isMissed() ? missedRuleMessage : this._customMessage;\n  }\n};\n\nvar manager = {\n  /**\n   * List of async rule names\n   *\n   * @type {Array}\n   */\n  asyncRules: [],\n\n  /**\n   * Implicit rules (rules to always validate)\n   *\n   * @type {Array}\n   */\n  implicitRules: [\n    \"required\",\n    \"required_if\",\n    \"required_unless\",\n    \"required_with\",\n    \"required_with_all\",\n    \"required_without\",\n    \"required_without_all\",\n    \"accepted\",\n    \"present\"\n  ],\n\n  /**\n   * Get rule by name\n   *\n   * @param  {string} name\n   * @param {Validator}\n   * @return {Rule}\n   */\n  make: function(name, validator) {\n    var async = this.isAsync(name);\n    var rule = new Rule(name, rules[name], async);\n    rule.setValidator(validator);\n    return rule;\n  },\n\n  /**\n   * Determine if given rule is async\n   *\n   * @param  {string}  name\n   * @return {boolean}\n   */\n  isAsync: function(name) {\n    for (var i = 0, len = this.asyncRules.length; i < len; i++) {\n      if (this.asyncRules[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Determine if rule is implicit (should always validate)\n   *\n   * @param {string} name\n   * @return {boolean}\n   */\n  isImplicit: function(name) {\n    return this.implicitRules.indexOf(name) > -1;\n  },\n\n  /**\n   * Register new rule\n   *\n   * @param  {string}   name\n   * @param  {function} fn\n   * @return {void}\n   */\n  register: function(name, fn) {\n    rules[name] = fn;\n  },\n\n  /**\n   * Register new implicit rule\n   *\n   * @param  {string}   name\n   * @param  {function} fn\n   * @return {void}\n   */\n  registerImplicit: function(name, fn) {\n    this.register(name, fn);\n    this.implicitRules.push(name);\n  },\n\n  /**\n   * Register async rule\n   *\n   * @param  {string}   name\n   * @param  {function} fn\n   * @return {void}\n   */\n  registerAsync: function(name, fn) {\n    this.register(name, fn);\n    this.asyncRules.push(name);\n  },\n\n  /**\n   * Register implicit async rule\n   *\n   * @param  {string}   name\n   * @param  {function} fn\n   * @return {void}\n   */\n  registerAsyncImplicit: function(name, fn) {\n    this.registerImplicit(name, fn);\n    this.asyncRules.push(name);\n  },\n\n  registerMissedRuleValidator: function(fn, message) {\n    missedRuleValidator = fn;\n    missedRuleMessage = message;\n  }\n};\n\nmodule.exports = manager;\n","var replacements = {\n\n  /**\n   * Between replacement (replaces :min and :max)\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  between: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      min: parameters[0],\n      max: parameters[1]\n    });\n  },\n\n  /**\n   * Digits-Between replacement (replaces :min and :max)\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  digits_between: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      min: parameters[0],\n      max: parameters[1]\n    });\n  },\n\n  /**\n   * Required_if replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  required_if: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      other: this._getAttributeName(parameters[0]),\n      value: parameters[1]\n    });\n  },\n\n  /**\n   * Required_unless replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  required_unless: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      other: this._getAttributeName(parameters[0]),\n      value: parameters[1]\n    });\n  },\n\n  /**\n   * Required_with replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  required_with: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      field: this._getAttributeName(parameters[0])\n    });\n  },\n\n  /**\n   * Required_with_all replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  required_with_all: function(template, rule) {\n    var parameters = rule.getParameters();\n    var getAttributeName = this._getAttributeName.bind(this);\n    return this._replacePlaceholders(rule, template, {\n      fields: parameters.map(getAttributeName).join(', ')\n    });\n  },\n\n  /**\n   * Required_without replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  required_without: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      field: this._getAttributeName(parameters[0])\n    });\n  },\n\n  /**\n   * Required_without_all replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  required_without_all: function(template, rule) {\n    var parameters = rule.getParameters();\n    var getAttributeName = this._getAttributeName.bind(this);\n    return this._replacePlaceholders(rule, template, {\n      fields: parameters.map(getAttributeName).join(', ')\n    });\n  },\n\n  /**\n   * After replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  after: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      after: this._getAttributeName(parameters[0])\n    });\n  },\n\n  /**\n   * Before replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  before: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      before: this._getAttributeName(parameters[0])\n    });\n  },\n\n  /**\n   * After_or_equal replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  after_or_equal: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      after_or_equal: this._getAttributeName(parameters[0])\n    });\n  },\n\n  /**\n   * Before_or_equal replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  before_or_equal: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      before_or_equal: this._getAttributeName(parameters[0])\n    });\n  },\n\n  /**\n   * Same replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  same: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      same: this._getAttributeName(parameters[0])\n    });\n  },\n};\n\nfunction formatter(attribute) {\n  return attribute.replace(/[_\\[]/g, ' ').replace(/]/g, '');\n}\n\nmodule.exports = {\n  replacements: replacements,\n  formatter: formatter\n};\n","var Attributes = require('./attributes');\n\nvar Messages = function(lang, messages) {\n  this.lang = lang;\n  this.messages = messages;\n  this.customMessages = {};\n  this.attributeNames = {};\n};\n\nMessages.prototype = {\n  constructor: Messages,\n\n  /**\n   * Set custom messages\n   *\n   * @param {object} customMessages\n   * @return {void}\n   */\n  _setCustom: function(customMessages) {\n    this.customMessages = customMessages || {};\n  },\n\n  /**\n   * Set custom attribute names.\n   *\n   * @param {object} attributes\n   */\n  _setAttributeNames: function(attributes) {\n    this.attributeNames = attributes;\n  },\n\n  /**\n   * Set the attribute formatter.\n   *\n   * @param {fuction} func\n   * @return {void}\n   */\n  _setAttributeFormatter: function(func) {\n    this.attributeFormatter = func;\n  },\n\n  /**\n   * Get attribute name to display.\n   *\n   * @param  {string} attribute\n   * @return {string}\n   */\n  _getAttributeName: function(attribute) {\n    var name = attribute;\n    if (this.attributeNames.hasOwnProperty(attribute)) {\n      return this.attributeNames[attribute];\n    } else if (this.messages.attributes.hasOwnProperty(attribute)) {\n      name = this.messages.attributes[attribute];\n    }\n\n    if (this.attributeFormatter) {\n      name = this.attributeFormatter(name);\n    }\n\n    return name;\n  },\n\n  /**\n   * Get all messages\n   *\n   * @return {object}\n   */\n  all: function() {\n    return this.messages;\n  },\n\n  /**\n   * Render message\n   *\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  render: function(rule) {\n    if (rule.customMessage) {\n      return rule.customMessage;\n    }\n    var template = this._getTemplate(rule);\n\n    var message;\n    if (Attributes.replacements[rule.name]) {\n      message = Attributes.replacements[rule.name].apply(this, [template, rule]);\n    } else {\n      message = this._replacePlaceholders(rule, template, {});\n    }\n\n    return message;\n  },\n\n  /**\n   * Get the template to use for given rule\n   *\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  _getTemplate: function(rule) {\n\n    var messages = this.messages;\n    var template = messages.def;\n    var customMessages = this.customMessages;\n    var formats = [rule.name + '.' + rule.attribute, rule.name];\n\n    for (var i = 0, format; i < formats.length; i++) {\n      format = formats[i];\n      if (customMessages.hasOwnProperty(format)) {\n        template = customMessages[format];\n        break;\n      } else if (messages.hasOwnProperty(format)) {\n        template = messages[format];\n        break;\n      }\n    }\n\n    if (typeof template === 'object') {\n      template = template[rule._getValueType()];\n    }\n\n    return template;\n  },\n\n  /**\n   * Replace placeholders in the template using the data object\n   *\n   * @param  {Rule} rule\n   * @param  {string} template\n   * @param  {object} data\n   * @return {string}\n   */\n  _replacePlaceholders: function(rule, template, data) {\n    var message, attribute;\n\n    data.attribute = this._getAttributeName(rule.attribute);\n    data[rule.name] = data[rule.name] || rule.getParameters().join(',');\n\n    if (typeof template === 'string' && typeof data === 'object') {\n      message = template;\n\n      for (attribute in data) {\n        message = message.replace(new RegExp(':' + attribute, 'g'), data[attribute]);\n      }\n    }\n\n    return message;\n  }\n\n};\n\nmodule.exports = Messages;\n","module.exports = {\n  accepted: 'The :attribute must be accepted.',\n  after: 'The :attribute must be after :after.',\n  after_or_equal: 'The :attribute must be equal or after :after_or_equal.',\n  alpha: 'The :attribute field must contain only alphabetic characters.',\n  alpha_dash: 'The :attribute field may only contain alpha-numeric characters, as well as dashes and underscores.',\n  alpha_num: 'The :attribute field must be alphanumeric.',\n  before: 'The :attribute must be before :before.',\n  before_or_equal: 'The :attribute must be equal or before :before_or_equal.',\n  between: 'The :attribute field must be between :min and :max.',\n  confirmed: 'The :attribute confirmation does not match.',\n  email: 'The :attribute format is invalid.',\n  date: 'The :attribute is not a valid date format.',\n  def: 'The :attribute attribute has errors.',\n  digits: 'The :attribute must be :digits digits.',\n  digits_between: 'The :attribute field must be between :min and :max digits.',\n  different: 'The :attribute and :different must be different.',\n  in: 'The selected :attribute is invalid.',\n  integer: 'The :attribute must be an integer.',\n  hex: 'The :attribute field should have hexadecimal format',\n  min: {\n    numeric: 'The :attribute must be at least :min.',\n    string: 'The :attribute must be at least :min characters.'\n  },\n  max: {\n    numeric: 'The :attribute may not be greater than :max.',\n    string: 'The :attribute may not be greater than :max characters.'\n  },\n  not_in: 'The selected :attribute is invalid.',\n  numeric: 'The :attribute must be a number.',\n  present: 'The :attribute field must be present (but can be empty).',\n  required: 'The :attribute field is required.',\n  required_if: 'The :attribute field is required when :other is :value.',\n  required_unless: 'The :attribute field is required when :other is not :value.',\n  required_with: 'The :attribute field is required when :field is not empty.',\n  required_with_all: 'The :attribute field is required when :fields are not empty.',\n  required_without: 'The :attribute field is required when :field is empty.',\n  required_without_all: 'The :attribute field is required when :fields are empty.',\n  same: 'The :attribute and :same fields must match.',\n  size: {\n    numeric: 'The :attribute must be :size.',\n    string: 'The :attribute must be :size characters.'\n  },\n  string: 'The :attribute must be a string.',\n  url: 'The :attribute format is invalid.',\n  regex: 'The :attribute format is invalid.',\n  attributes: {}\n};\n","var Messages = require('./messages');\n\nrequire('./lang/en');\n\nvar require_method = require;\n\nvar container = {\n\n  messages: {},\n\n  /**\n   * Set messages for language\n   *\n   * @param {string} lang\n   * @param {object} rawMessages\n   * @return {void}\n   */\n  _set: function(lang, rawMessages) {\n    this.messages[lang] = rawMessages;\n  },\n\n  /**\n   * Set message for given language's rule.\n   *\n   * @param {string} lang\n   * @param {string} attribute\n   * @param {string|object} message\n   * @return {void}\n   */\n  _setRuleMessage: function(lang, attribute, message) {\n    this._load(lang);\n    if (message === undefined) {\n      message = this.messages[lang].def;\n    }\n\n    this.messages[lang][attribute] = message;\n  },\n\n  /**\n   * Load messages (if not already loaded)\n   *\n   * @param  {string} lang\n   * @return {void}\n   */\n  _load: function(lang) {\n    if (!this.messages[lang]) {\n      try {\n        var rawMessages = require_method('./lang/' + lang);\n        this._set(lang, rawMessages);\n      } catch (e) {}\n    }\n  },\n\n  /**\n   * Get raw messages for language\n   *\n   * @param  {string} lang\n   * @return {object}\n   */\n  _get: function(lang) {\n    this._load(lang);\n    return this.messages[lang];\n  },\n\n  /**\n   * Make messages for given language\n   *\n   * @param  {string} lang\n   * @return {Messages}\n   */\n  _make: function(lang) {\n    this._load(lang);\n    return new Messages(lang, this.messages[lang]);\n  }\n\n};\n\nmodule.exports = container;\n","var Errors = function() {\n  this.errors = {};\n};\n\nErrors.prototype = {\n  constructor: Errors,\n\n  /**\n   * Add new error message for given attribute\n   *\n   * @param  {string} attribute\n   * @param  {string} message\n   * @return {void}\n   */\n  add: function(attribute, message) {\n    if (!this.has(attribute)) {\n      this.errors[attribute] = [];\n    }\n\n    if (this.errors[attribute].indexOf(message) === -1) {\n      this.errors[attribute].push(message);\n    }\n  },\n\n  /**\n   * Returns an array of error messages for an attribute, or an empty array\n   *\n   * @param  {string} attribute A key in the data object being validated\n   * @return {array} An array of error messages\n   */\n  get: function(attribute) {\n    if (this.has(attribute)) {\n      return this.errors[attribute];\n    }\n\n    return [];\n  },\n\n  /**\n   * Returns the first error message for an attribute, false otherwise\n   *\n   * @param  {string} attribute A key in the data object being validated\n   * @return {string|false} First error message or false\n   */\n  first: function(attribute) {\n    if (this.has(attribute)) {\n      return this.errors[attribute][0];\n    }\n\n    return false;\n  },\n\n  /**\n   * Get all error messages from all failing attributes\n   *\n   * @return {Object} Failed attribute names for keys and an array of messages for values\n   */\n  all: function() {\n    return this.errors;\n  },\n\n  /**\n   * Determine if there are any error messages for an attribute\n   *\n   * @param  {string}  attribute A key in the data object being validated\n   * @return {boolean}\n   */\n  has: function(attribute) {\n    if (this.errors.hasOwnProperty(attribute)) {\n      return true;\n    }\n\n    return false;\n  }\n};\n\nmodule.exports = Errors;\n","function AsyncResolvers(onFailedOne, onResolvedAll) {\n  this.onResolvedAll = onResolvedAll;\n  this.onFailedOne = onFailedOne;\n  this.resolvers = {};\n  this.resolversCount = 0;\n  this.passed = [];\n  this.failed = [];\n  this.firing = false;\n}\n\nAsyncResolvers.prototype = {\n\n  /**\n   * Add resolver\n   *\n   * @param {Rule} rule\n   * @return {integer}\n   */\n  add: function(rule) {\n    var index = this.resolversCount;\n    this.resolvers[index] = rule;\n    this.resolversCount++;\n    return index;\n  },\n\n  /**\n   * Resolve given index\n   *\n   * @param  {integer} index\n   * @return {void}\n   */\n  resolve: function(index) {\n    var rule = this.resolvers[index];\n    if (rule.passes === true) {\n      this.passed.push(rule);\n    } else if (rule.passes === false) {\n      this.failed.push(rule);\n      this.onFailedOne(rule);\n    }\n\n    this.fire();\n  },\n\n  /**\n   * Determine if all have been resolved\n   *\n   * @return {boolean}\n   */\n  isAllResolved: function() {\n    return (this.passed.length + this.failed.length) === this.resolversCount;\n  },\n\n  /**\n   * Attempt to fire final all resolved callback if completed\n   *\n   * @return {void}\n   */\n  fire: function() {\n\n    if (!this.firing) {\n      return;\n    }\n\n    if (this.isAllResolved()) {\n      this.onResolvedAll(this.failed.length === 0);\n    }\n\n  },\n\n  /**\n   * Enable firing\n   *\n   * @return {void}\n   */\n  enableFiring: function() {\n    this.firing = true;\n  }\n\n};\n\nmodule.exports = AsyncResolvers;\n","var Rules = require('./rules');\nvar Lang = require('./lang');\nvar Errors = require('./errors');\nvar Attributes = require('./attributes');\nvar AsyncResolvers = require('./async');\n\nvar Validator = function (input, rules, customMessages) {\n  var lang = Validator.getDefaultLang();\n  this.input = input || {};\n\n  this.messages = Lang._make(lang);\n  this.messages._setCustom(customMessages);\n  this.setAttributeFormatter(Validator.prototype.attributeFormatter);\n\n  this.errors = new Errors();\n  this.errorCount = 0;\n\n  this.hasAsync = false;\n  this.rules = this._parseRules(rules);\n};\n\nValidator.prototype = {\n\n  constructor: Validator,\n\n  /**\n   * Default language\n   *\n   * @type {string}\n   */\n  lang: 'en',\n\n  /**\n   * Numeric based rules\n   *\n   * @type {array}\n   */\n  numericRules: ['integer', 'numeric'],\n\n  /**\n   * Attribute formatter.\n   *\n   * @type {function}\n   */\n  attributeFormatter: Attributes.formatter,\n\n  /**\n   * Run validator\n   *\n   * @return {boolean} Whether it passes; true = passes, false = fails\n   */\n  check: function () {\n    var self = this;\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {\n        ruleOptions = attributeRules[i];\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);\n        if (!rulePassed) {\n          this._addFailure(rule);\n        }\n\n        if (this._shouldStopValidating(attribute, rulePassed)) {\n          break;\n        }\n      }\n    }\n\n    return this.errorCount === 0;\n  },\n\n  /**\n   * Run async validator\n   *\n   * @param {function} passes\n   * @param {function} fails\n   * @return {void}\n   */\n  checkAsync: function (passes, fails) {\n    var _this = this;\n    passes = passes || function () {};\n    fails = fails || function () {};\n\n    var failsOne = function (rule, message) {\n      _this._addFailure(rule, message);\n    };\n\n    var resolvedAll = function (allPassed) {\n      if (allPassed) {\n        passes();\n      } else {\n        fails();\n      }\n    };\n\n    var asyncResolvers = new AsyncResolvers(failsOne, resolvedAll);\n\n    var validateRule = function (inputValue, ruleOptions, attribute, rule) {\n      return function () {\n        var resolverIndex = asyncResolvers.add(rule);\n        rule.validate(inputValue, ruleOptions.value, attribute, function () {\n          asyncResolvers.resolve(resolverIndex);\n        });\n      };\n    };\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {\n        ruleOptions = attributeRules[i];\n\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        validateRule(inputValue, ruleOptions, attribute, rule)();\n      }\n    }\n\n    asyncResolvers.enableFiring();\n    asyncResolvers.fire();\n  },\n\n  /**\n   * Add failure and error message for given rule\n   *\n   * @param {Rule} rule\n   */\n  _addFailure: function (rule) {\n    var msg = this.messages.render(rule);\n    this.errors.add(rule.attribute, msg);\n    this.errorCount++;\n  },\n\n  /**\n   * Flatten nested object, normalizing { foo: { bar: 1 } } into: { 'foo.bar': 1 }\n   *\n   * @param  {object} nested object\n   * @return {object} flattened object\n   */\n  _flattenObject: function (obj) {\n    var flattened = {};\n\n    function recurse(current, property) {\n      if (!property && Object.getOwnPropertyNames(current).length === 0) {\n        return;\n      }\n      if (Object(current) !== current || Array.isArray(current)) {\n        flattened[property] = current;\n      } else {\n        var isEmpty = true;\n        for (var p in current) {\n          isEmpty = false;\n          recurse(current[p], property ? property + '.' + p : p);\n        }\n        if (isEmpty) {\n          flattened[property] = {};\n        }\n      }\n    }\n    if (obj) {\n      recurse(obj);\n    }\n    return flattened;\n  },\n\n  /**\n   * Extract value from nested object using string path with dot notation\n   *\n   * @param  {object} object to search in\n   * @param  {string} path inside object\n   * @return {any|void} value under the path\n   */\n  _objectPath: function (obj, path) {\n    if (Object.prototype.hasOwnProperty.call(obj, path)) {\n      return obj[path];\n    }\n\n    var keys = path.replace(/\\[(\\w+)\\]/g, '.$1').replace(/^\\./, '').split('.');\n    var copy = {};\n    for (var attr in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n\n    for (var i = 0, l = keys.length; i < l; i++) {\n      if (typeof copy === 'object' && copy !== null && Object.hasOwnProperty.call(copy, keys[i])) {\n        copy = copy[keys[i]];\n      } else {\n        return;\n      }\n    }\n    return copy;\n  },\n\n  /**\n   * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }\n   *\n   * @param  {object} rules\n   * @return {object}\n   */\n  _parseRules: function (rules) {\n\n    var parsedRules = {};\n    rules = this._flattenObject(rules);\n\n    for (var attribute in rules) {\n\n      var rulesArray = rules[attribute];\n\n      this._parseRulesCheck(attribute, rulesArray, parsedRules);\n    }\n    return parsedRules;\n\n\n  },\n\n  _parseRulesCheck: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    if (attribute.indexOf('*') > -1) {\n      this._parsedRulesRecurse(attribute, rulesArray, parsedRules, wildCardValues);\n    } else {\n      this._parseRulesDefault(attribute, rulesArray, parsedRules, wildCardValues);\n    }\n  },\n\n  _parsedRulesRecurse: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var parentPath = attribute.substr(0, attribute.indexOf('*') - 1);\n    var propertyValue = this._objectPath(this.input, parentPath);\n\n    if (propertyValue) {\n      for (var propertyNumber = 0; propertyNumber < propertyValue.length; propertyNumber++) {\n        var workingValues = wildCardValues ? wildCardValues.slice() : [];\n        workingValues.push(propertyNumber);\n        this._parseRulesCheck(attribute.replace('*', propertyNumber), rulesArray, parsedRules, workingValues);\n      }\n    }\n  },\n\n  _parseRulesDefault: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var attributeRules = [];\n\n    if (rulesArray instanceof Array) {\n      rulesArray = this._prepareRulesArray(rulesArray);\n    }\n\n    if (typeof rulesArray === 'string') {\n      rulesArray = rulesArray.split('|');\n    }\n\n    for (var i = 0, len = rulesArray.length, rule; i < len; i++) {\n      rule = typeof rulesArray[i] === 'string' ? this._extractRuleAndRuleValue(rulesArray[i]) : rulesArray[i];\n      if (rule.value) {\n        rule.value = this._replaceWildCards(rule.value, wildCardValues);\n        this._replaceWildCardsMessages(wildCardValues);\n      }\n\n      if (Rules.isAsync(rule.name)) {\n        this.hasAsync = true;\n      }\n      attributeRules.push(rule);\n    }\n\n    parsedRules[attribute] = attributeRules;\n  },\n\n  _replaceWildCards: function (path, nums) {\n\n    if (!nums) {\n      return path;\n    }\n\n    var path2 = path;\n    nums.forEach(function (value) {\n      if(Array.isArray(path2)){\n        path2 = path2[0];\n      }\n      const pos = path2.indexOf('*');\n      if (pos === -1) {\n        return path2;\n      }\n      path2 = path2.substr(0, pos) + value + path2.substr(pos + 1);\n    });\n    if(Array.isArray(path)){\n      path[0] = path2;\n      path2 = path;\n    }\n    return path2;\n  },\n\n  _replaceWildCardsMessages: function (nums) {\n    var customMessages = this.messages.customMessages;\n    var self = this;\n    Object.keys(customMessages).forEach(function (key) {\n      if (nums) {\n        var newKey = self._replaceWildCards(key, nums);\n        customMessages[newKey] = customMessages[key];\n      }\n    });\n\n    this.messages._setCustom(customMessages);\n  },\n  /**\n   * Prepare rules if it comes in Array. Check for objects. Need for type validation.\n   *\n   * @param  {array} rulesArray\n   * @return {array}\n   */\n  _prepareRulesArray: function (rulesArray) {\n    var rules = [];\n\n    for (var i = 0, len = rulesArray.length; i < len; i++) {\n      if (typeof rulesArray[i] === 'object') {\n        for (var rule in rulesArray[i]) {\n          rules.push({\n            name: rule,\n            value: rulesArray[i][rule]\n          });\n        }\n      } else {\n        rules.push(rulesArray[i]);\n      }\n    }\n\n    return rules;\n  },\n\n  /**\n   * Determines if the attribute is supplied with the original data object.\n   *\n   * @param  {array} attribute\n   * @return {boolean}\n   */\n  _suppliedWithData: function (attribute) {\n    return this.input.hasOwnProperty(attribute);\n  },\n\n  /**\n   * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3\n   *\n   * @param  {string} ruleString min:3\n   * @return {object} object containing the name of the rule and value\n   */\n  _extractRuleAndRuleValue: function (ruleString) {\n    var rule = {},\n      ruleArray;\n\n    rule.name = ruleString;\n\n    if (ruleString.indexOf(':') >= 0) {\n      ruleArray = ruleString.split(':');\n      rule.name = ruleArray[0];\n      rule.value = ruleArray.slice(1).join(':');\n    }\n\n    return rule;\n  },\n\n  /**\n   * Determine if attribute has any of the given rules\n   *\n   * @param  {string}  attribute\n   * @param  {array}   findRules\n   * @return {boolean}\n   */\n  _hasRule: function (attribute, findRules) {\n    var rules = this.rules[attribute] || [];\n    for (var i = 0, len = rules.length; i < len; i++) {\n      if (findRules.indexOf(rules[i].name) > -1) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Determine if attribute has any numeric-based rules.\n   *\n   * @param  {string}  attribute\n   * @return {Boolean}\n   */\n  _hasNumericRule: function (attribute) {\n    return this._hasRule(attribute, this.numericRules);\n  },\n\n  /**\n   * Determine if rule is validatable\n   *\n   * @param  {Rule}   rule\n   * @param  {mixed}  value\n   * @return {boolean}\n   */\n  _isValidatable: function (rule, value) {\n    if (Array.isArray(value)) {\n      return true;\n    }\n    if (Rules.isImplicit(rule.name)) {\n      return true;\n    }\n\n    return this.getRule('required').validate(value);\n  },\n\n  /**\n   * Determine if we should stop validating.\n   *\n   * @param  {string} attribute\n   * @param  {boolean} rulePassed\n   * @return {boolean}\n   */\n  _shouldStopValidating: function (attribute, rulePassed) {\n\n    var stopOnAttributes = this.stopOnAttributes;\n    if (typeof stopOnAttributes === 'undefined' || stopOnAttributes === false || rulePassed === true) {\n      return false;\n    }\n\n    if (stopOnAttributes instanceof Array) {\n      return stopOnAttributes.indexOf(attribute) > -1;\n    }\n\n    return true;\n  },\n\n  /**\n   * Set custom attribute names.\n   *\n   * @param {object} attributes\n   * @return {void}\n   */\n  setAttributeNames: function (attributes) {\n    this.messages._setAttributeNames(attributes);\n  },\n\n  /**\n   * Set the attribute formatter.\n   *\n   * @param {fuction} func\n   * @return {void}\n   */\n  setAttributeFormatter: function (func) {\n    this.messages._setAttributeFormatter(func);\n  },\n\n  /**\n   * Get validation rule\n   *\n   * @param  {string} name\n   * @return {Rule}\n   */\n  getRule: function (name) {\n    return Rules.make(name, this);\n  },\n\n  /**\n   * Stop on first error.\n   *\n   * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n   * @return {void}\n   */\n  stopOnError: function (attributes) {\n    this.stopOnAttributes = attributes;\n  },\n\n  /**\n   * Determine if validation passes\n   *\n   * @param {function} passes\n   * @return {boolean|undefined}\n   */\n  passes: function (passes) {\n    var async = this._checkAsync('passes', passes);\n    if (async) {\n      return this.checkAsync(passes);\n    }\n    return this.check();\n  },\n\n  /**\n   * Determine if validation fails\n   *\n   * @param {function} fails\n   * @return {boolean|undefined}\n   */\n  fails: function (fails) {\n    var async = this._checkAsync('fails', fails);\n    if (async) {\n      return this.checkAsync(function () {}, fails);\n    }\n    return !this.check();\n  },\n\n  /**\n   * Check if validation should be called asynchronously\n   *\n   * @param  {string}   funcName Name of the caller\n   * @param  {function} callback\n   * @return {boolean}\n   */\n  _checkAsync: function (funcName, callback) {\n    var hasCallback = typeof callback === 'function';\n    if (this.hasAsync && !hasCallback) {\n      throw funcName + ' expects a callback when async rules are being tested.';\n    }\n\n    return this.hasAsync || hasCallback;\n  }\n\n};\n\n/**\n * Set messages for language\n *\n * @param {string} lang\n * @param {object} messages\n * @return {this}\n */\nValidator.setMessages = function (lang, messages) {\n  Lang._set(lang, messages);\n  return this;\n};\n\n/**\n * Get messages for given language\n *\n * @param  {string} lang\n * @return {Messages}\n */\nValidator.getMessages = function (lang) {\n  return Lang._get(lang);\n};\n\n/**\n * Set default language to use\n *\n * @param {string} lang\n * @return {void}\n */\nValidator.useLang = function (lang) {\n  this.prototype.lang = lang;\n};\n\n/**\n * Get default language\n *\n * @return {string}\n */\nValidator.getDefaultLang = function () {\n  return this.prototype.lang;\n};\n\n/**\n * Set the attribute formatter.\n *\n * @param {fuction} func\n * @return {void}\n */\nValidator.setAttributeFormatter = function (func) {\n  this.prototype.attributeFormatter = func;\n};\n\n/**\n * Stop on first error.\n *\n * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n * @return {void}\n */\nValidator.stopOnError = function (attributes) {\n  this.prototype.stopOnAttributes = attributes;\n};\n\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.register = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.register(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @param  {function} fnReplacement\n * @return {void}\n */\nValidator.registerImplicit = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerImplicit(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerAsync = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsync(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerAsyncImplicit = function (name, fn, message) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsyncImplicit(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register validator for missed validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerMissedRuleValidator = function(fn, message) {\n  Rules.registerMissedRuleValidator(fn, message);\n};\n\nmodule.exports = Validator;\n","class ValidatorEngine {\r\n\r\n    constructor(state, dictionary, rules, input, metadata, customErrorMessages) {\r\n\r\n    }\r\n\r\n\r\n\r\n    /* HELPER FUNCTIONS */\r\n\r\n    // Return the single dictionary term that most closely resembles the search term\r\n    fuzzyMatchTerm(searchTerm, dictionary) {\r\n        const stringSimilarity = require('string-similarity');\r\n        const a = stringSimilarity.findBestMatch(searchTerm, dictionary);\r\n\r\n        // If the Dice's coefficient falls below threshold, return null\r\n        if (a.bestMatch.rating <= 0.25) {\r\n            return null\r\n        } else {\r\n            return a.bestMatch.target;\r\n        }\r\n    }\r\n\r\n    // Takes a raw array and dictionary and returns a fuzzy-matched array\r\n    fuzzyMatchArray(rawArray, dictionary) {\r\n        const matchedArray = [];\r\n        for (let i = 0; i < rawArray.length; i++) {\r\n            const match = this.fuzzyMatchTerm(rawArray[i], dictionary);\r\n            matchedArray.push(match);\r\n        }\r\n        return matchedArray;\r\n    }\r\n\r\n    // For every item in the array, change to lowercase and remove special characters. Returns newly cleaned array\r\n    cleanArray(rawArray) {\r\n        const cleanArr = [];\r\n        for (let i = 0; i < rawArray.length; i++) {\r\n            const cleanItem = rawArray[i].replace(/[^A-Z0-9]/ig, \" \").toLowerCase()\r\n            cleanArr.push(cleanItem)\r\n        }\r\n        return cleanArr;\r\n    }\r\n\r\n\r\n    // Validates a data source against a set of rules, and then returns pass / fail\r\n    validateData(data, rules, customErrorMessages) {\r\n        const Validator = require('validatorjs');\r\n        console.log(\"validateData function\")\r\n        let validation = new Validator(data, rules, customErrorMessages)\r\n        console.log(\"Passed validation?\", validation.passes())\r\n        return Object.values(validation.errors.errors)\r\n    }\r\n\r\n    // Updates an object's keys\r\n    updateKeys(oldArr, newArr) {\r\n        for (let i = 0; i < oldArr.length; i++) {\r\n            newArr[i] = oldArr[i];\r\n            console.log(`Matched ${oldArr[i]} with ${newArr[i]}`)\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /* VALIDATION FUNCTIONS */\r\n\r\n    // Checks that the data file contains the right headers\r\n    checkHeaders(state, metadata, dictionary) {\r\n        let matchedHeaders = this.fuzzyMatchArray(metadata.headers, dictionary.headers)\r\n        let originalHeaders = Object.keys(state.raw[0])\r\n        this.updateKeys(originalHeaders, matchedHeaders)\r\n        console.log(\"Old keys\", Object.keys(state.raw[0]))\r\n        console.log(\"New keys\", matchedHeaders)\r\n    }\r\n\r\n    // Checks that required columns are 100% filled in\r\n    checkRequired(state) {\r\n        console.log(\"Checking required columns are filled in\")\r\n    }\r\n\r\n    // Checks that each column contains the right data type\r\n    checkDataType(state) {\r\n        console.log(\"Checking data types\")\r\n    }\r\n\r\n    // Generates a fuzzy-matched version of each picklist column\r\n    fuzzyMatchPicklists(state) {\r\n        console.log(\"Fuzzy-matching picklist columns\")\r\n    }\r\n\r\n    // Calculates subpopulation from fuzzy-matched chronic and veteran status\r\n    getSubpop(householdType, chronicArray, veteranArray) {\r\n        const subpopArray = [];\r\n        for (let i = 0; i < householdType.length; i++) {\r\n            if (householdType[i] === \"single adult\" && chronicArray[i] === \"chronic\" && veteranArray[i] === \"no\") {\r\n                let s = \"chronic\";\r\n                subpopArray.push(s);\r\n            }\r\n        }\r\n        return subpopArray;\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\nexport {\r\n    ValidatorEngine\r\n};"]}